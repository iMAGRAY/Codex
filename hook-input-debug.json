{"session_id":"4488b876-1f58-408b-a41d-ea614da23815","transcript_path":"C:\\Users\\1\\.claude\\projects\\C--Users-1-Documents-GitHub-codex\\4488b876-1f58-408b-a41d-ea614da23815.jsonl","cwd":"C:\\Users\\1\\Documents\\GitHub\\codex","permission_mode":"default","hook_event_name":"PostToolUse","tool_name":"MultiEdit","tool_input":{"file_path":"C:\\Users\\1\\Documents\\GitHub\\codex\\codex-rs\\core\\src\\auth.rs","edits":[{"old_string":"    pub fn switch_to_next_account(&self) -> std::io::Result<bool> {\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n\n        if !auth_dot_json.rotation_enabled() {\n            return Ok(false);\n        }\n\n        let total = auth_dot_json.accounts.len();\n        if total <= 1 {\n            return Ok(false);\n        }\n\n        let current = auth_dot_json.active_index();\n        let now = Utc::now();\n\n        for offset in 1..total {\n            let candidate = (current + offset) % total;\n            let available = auth_dot_json\n                .accounts\n                .get(candidate)\n                .map(|account| account.is_available(now) && account.tokens.is_some())\n                .unwrap_or(false);\n\n            if available {\n                auth_dot_json.set_active_index(candidate);\n                if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {\n                    account.clear_rate_limit();\n                }\n                write_auth_json(&auth_file, &auth_dot_json)?;\n                self.reload();\n                update_account_pool_state(|state| {\n                    state.last_rotation_at = Some(Utc::now());\n                });\n                return Ok(true);\n            }\n        }\n\n        Ok(false)\n    }","new_string":"    pub fn switch_to_next_account(&self) -> std::io::Result<bool> {\n        use tracing::debug;\n        use tracing::warn;\n\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n\n        if !auth_dot_json.rotation_enabled() {\n            debug!(\"Account rotation disabled\");\n            return Ok(false);\n        }\n\n        let total = auth_dot_json.accounts.len();\n        if total <= 1 {\n            debug!(\"Only {} account(s) available, cannot rotate\", total);\n            return Ok(false);\n        }\n\n        let current = auth_dot_json.active_index();\n        let now = Utc::now();\n        debug!(\"Current account index: {}, total accounts: {}\", current, total);\n\n        for offset in 1..total {\n            let candidate = (current + offset) % total;\n            let account = match auth_dot_json.accounts.get(candidate) {\n                Some(acc) => acc,\n                None => {\n                    warn!(\"Account at index {} not found\", candidate);\n                    continue;\n                }\n            };\n\n            // Check if account has valid tokens\n            let has_valid_tokens = account.tokens.as_ref()\n                .map(|t| !t.access_token.is_empty() && !t.refresh_token.is_empty())\n                .unwrap_or(false);\n\n            if !has_valid_tokens {\n                debug!(\"Account {} has no valid tokens, skipping\", candidate);\n                continue;\n            }\n\n            if !account.is_available(now) {\n                if let Some(reset) = account.rate_limit_reset {\n                    debug!(\"Account {} is rate limited until {}\", candidate, reset);\n                }\n                continue;\n            }\n\n            debug!(\"Switching from account {} to account {}\", current, candidate);\n            auth_dot_json.set_active_index(candidate);\n            if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {\n                account.clear_rate_limit();\n            }\n            write_auth_json(&auth_file, &auth_dot_json)?;\n            self.reload();\n            update_account_pool_state(|state| {\n                state.last_rotation_at = Some(Utc::now());\n            });\n            debug!(\"Successfully switched to account {}\", candidate);\n            return Ok(true);\n        }\n\n        warn!(\"No available accounts found for rotation. All {} accounts are either rate limited or have invalid tokens\", total);\n        Ok(false)\n    }"}]},"tool_response":{"filePath":"C:\\Users\\1\\Documents\\GitHub\\codex\\codex-rs\\core\\src\\auth.rs","edits":[{"old_string":"    pub fn switch_to_next_account(&self) -> std::io::Result<bool> {\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n\n        if !auth_dot_json.rotation_enabled() {\n            return Ok(false);\n        }\n\n        let total = auth_dot_json.accounts.len();\n        if total <= 1 {\n            return Ok(false);\n        }\n\n        let current = auth_dot_json.active_index();\n        let now = Utc::now();\n\n        for offset in 1..total {\n            let candidate = (current + offset) % total;\n            let available = auth_dot_json\n                .accounts\n                .get(candidate)\n                .map(|account| account.is_available(now) && account.tokens.is_some())\n                .unwrap_or(false);\n\n            if available {\n                auth_dot_json.set_active_index(candidate);\n                if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {\n                    account.clear_rate_limit();\n                }\n                write_auth_json(&auth_file, &auth_dot_json)?;\n                self.reload();\n                update_account_pool_state(|state| {\n                    state.last_rotation_at = Some(Utc::now());\n                });\n                return Ok(true);\n            }\n        }\n\n        Ok(false)\n    }","new_string":"    pub fn switch_to_next_account(&self) -> std::io::Result<bool> {\n        use tracing::debug;\n        use tracing::warn;\n\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n\n        if !auth_dot_json.rotation_enabled() {\n            debug!(\"Account rotation disabled\");\n            return Ok(false);\n        }\n\n        let total = auth_dot_json.accounts.len();\n        if total <= 1 {\n            debug!(\"Only {} account(s) available, cannot rotate\", total);\n            return Ok(false);\n        }\n\n        let current = auth_dot_json.active_index();\n        let now = Utc::now();\n        debug!(\"Current account index: {}, total accounts: {}\", current, total);\n\n        for offset in 1..total {\n            let candidate = (current + offset) % total;\n            let account = match auth_dot_json.accounts.get(candidate) {\n                Some(acc) => acc,\n                None => {\n                    warn!(\"Account at index {} not found\", candidate);\n                    continue;\n                }\n            };\n\n            // Check if account has valid tokens\n            let has_valid_tokens = account.tokens.as_ref()\n                .map(|t| !t.access_token.is_empty() && !t.refresh_token.is_empty())\n                .unwrap_or(false);\n\n            if !has_valid_tokens {\n                debug!(\"Account {} has no valid tokens, skipping\", candidate);\n                continue;\n            }\n\n            if !account.is_available(now) {\n                if let Some(reset) = account.rate_limit_reset {\n                    debug!(\"Account {} is rate limited until {}\", candidate, reset);\n                }\n                continue;\n            }\n\n            debug!(\"Switching from account {} to account {}\", current, candidate);\n            auth_dot_json.set_active_index(candidate);\n            if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {\n                account.clear_rate_limit();\n            }\n            write_auth_json(&auth_file, &auth_dot_json)?;\n            self.reload();\n            update_account_pool_state(|state| {\n                state.last_rotation_at = Some(Utc::now());\n            });\n            debug!(\"Successfully switched to account {}\", candidate);\n            return Ok(true);\n        }\n\n        warn!(\"No available accounts found for rotation. All {} accounts are either rate limited or have invalid tokens\", total);\n        Ok(false)\n    }","replace_all":false}],"originalFileContents":"use chrono::DateTime;\nuse chrono::Utc;\nuse once_cell::sync::Lazy;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse std::env;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::Read;\nuse std::io::Write;\n#[cfg(unix)]\nuse std::os::unix::fs::OpenOptionsExt;\nuse std::path::Path;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::time::Duration;\n\nuse codex_protocol::mcp_protocol::AuthMode;\n\nuse crate::token_data::PlanType;\nuse crate::token_data::TokenData;\nuse crate::token_data::parse_id_token;\n\n#[derive(Debug, Clone)]\npub struct CodexAuth {\n    pub mode: AuthMode,\n\n    pub(crate) api_key: Option<String>,\n    pub(crate) active_account_index: Option<usize>,\n    pub(crate) auth_dot_json: Arc<Mutex<Option<AuthDotJson>>>,\n    pub(crate) auth_file: PathBuf,\n    pub(crate) client: reqwest::Client,\n}\n\nimpl PartialEq for CodexAuth {\n    fn eq(&self, other: &Self) -> bool {\n        self.mode == other.mode && self.active_account_index == other.active_account_index\n    }\n}\n\nimpl CodexAuth {\n    pub async fn refresh_token(&self) -> Result<String, std::io::Error> {\n        let token_data = self\n            .get_current_token_data()\n            .ok_or(std::io::Error::other(\"Token data is not available.\"))?;\n        let token = token_data.refresh_token;\n\n        let refresh_response = try_refresh_token(token, &self.client)\n            .await\n            .map_err(std::io::Error::other)?;\n\n        let updated = update_tokens(\n            &self.auth_file,\n            self.resolve_account_index(),\n            refresh_response.id_token,\n            refresh_response.access_token,\n            refresh_response.refresh_token,\n        )\n        .await?;\n\n        if let Ok(mut auth_lock) = self.auth_dot_json.lock() {\n            *auth_lock = Some(updated.clone());\n        }\n        let access = updated\n            .active_account()\n            .and_then(|account| account.tokens.as_ref())\n            .map(|t| t.access_token.clone())\n            .ok_or_else(|| std::io::Error::other(\"Token data is not available after refresh.\"))?;\n        Ok(access)\n    }\n\n    /// Loads the available auth information from the auth.json.\n    pub fn from_codex_home(codex_home: &Path) -> std::io::Result<Option<CodexAuth>> {\n        load_auth(codex_home)\n    }\n\n    pub async fn get_token_data(&self) -> Result<TokenData, std::io::Error> {\n        let auth_dot_json = self\n            .get_current_auth_json()\n            .ok_or(std::io::Error::other(\"Token data is not available.\"))?;\n\n        let account_index = self.resolve_account_index_with_fallback(&auth_dot_json);\n\n        let account = auth_dot_json\n            .accounts\n            .get(account_index)\n            .cloned()\n            .ok_or(std::io::Error::other(\"Token data is not available.\"))?;\n\n        let mut tokens = account\n            .tokens\n            .clone()\n            .ok_or(std::io::Error::other(\"Token data is not available.\"))?;\n        let last_refresh = account\n            .last_refresh\n            .ok_or(std::io::Error::other(\"Token data is not available.\"))?;\n\n        if last_refresh < Utc::now() - chrono::Duration::days(28) {\n            let refresh_response = tokio::time::timeout(\n                Duration::from_secs(60),\n                try_refresh_token(tokens.refresh_token.clone(), &self.client),\n            )\n            .await\n            .map_err(|_| std::io::Error::other(\"timed out while refreshing OpenAI API key\"))?\n            .map_err(std::io::Error::other)?;\n\n            let updated_auth_dot_json = update_tokens(\n                &self.auth_file,\n                Some(account_index),\n                refresh_response.id_token,\n                refresh_response.access_token,\n                refresh_response.refresh_token,\n            )\n            .await?;\n\n            tokens = updated_auth_dot_json\n                .accounts\n                .get(account_index)\n                .and_then(|acct| acct.tokens.clone())\n                .ok_or(std::io::Error::other(\n                    \"Token data is not available after refresh.\",\n                ))?;\n\n            #[expect(clippy::unwrap_used)]\n            let mut auth_lock = self.auth_dot_json.lock().unwrap();\n            *auth_lock = Some(updated_auth_dot_json);\n        }\n\n        Ok(tokens)\n    }\n\n    pub async fn get_token(&self) -> Result<String, std::io::Error> {\n        match self.mode {\n            AuthMode::ApiKey => Ok(self.api_key.clone().unwrap_or_default()),\n            AuthMode::ChatGPT => {\n                let id_token = self.get_token_data().await?.access_token;\n                Ok(id_token)\n            }\n        }\n    }\n\n    pub fn get_account_id(&self) -> Option<String> {\n        self.get_current_token_data().and_then(|t| t.account_id)\n    }\n\n    pub(crate) fn get_plan_type(&self) -> Option<PlanType> {\n        self.get_current_token_data()\n            .and_then(|t| t.id_token.chatgpt_plan_type)\n    }\n\n    pub fn account_pool_summary(&self) -> AccountPoolSummary {\n        let state = account_pool_state();\n        AccountPoolSummary {\n            total_accounts: state.total_accounts,\n            active_index: state.active_index,\n            rotation_enabled: state.rotation_enabled,\n            available_accounts: state.available_accounts,\n            cooldown_accounts: state.cooldown_accounts,\n            inactive_accounts: state.inactive_accounts,\n            next_available_at: state.next_available_at,\n            rate_limited_accounts: state.rate_limited_accounts,\n            last_rate_limit_at: state.last_rate_limit_at,\n            last_rotation_at: state.last_rotation_at,\n        }\n    }\n\n    fn get_current_auth_json(&self) -> Option<AuthDotJson> {\n        #[expect(clippy::unwrap_used)]\n        self.auth_dot_json.lock().unwrap().clone()\n    }\n\n    fn get_current_token_data(&self) -> Option<TokenData> {\n        let auth = self.get_current_auth_json()?;\n        if auth.accounts.is_empty() {\n            return auth.tokens;\n        }\n        let idx = self.resolve_account_index_with_fallback(&auth);\n        auth.accounts.get(idx).and_then(|acct| acct.tokens.clone())\n    }\n\n    fn resolve_account_index(&self) -> Option<usize> {\n        self.active_account_index\n            .or_else(|| self.get_current_auth_json().map(|auth| auth.active_index()))\n    }\n\n    fn resolve_account_index_with_fallback(&self, auth: &AuthDotJson) -> usize {\n        self.active_account_index\n            .or(auth.current_account_index)\n            .unwrap_or_else(|| auth.active_index())\n    }\n\n    /// Consider this private to integration tests.\n    pub fn create_dummy_chatgpt_auth_for_testing() -> Self {\n        let account = AuthAccount {\n            openai_api_key: None,\n            tokens: Some(TokenData {\n                id_token: Default::default(),\n                access_token: \"Access Token\".to_string(),\n                refresh_token: \"test\".to_string(),\n                account_id: Some(\"account_id\".to_string()),\n            }),\n            last_refresh: Some(Utc::now()),\n            rate_limit_reset: None,\n        };\n\n        let mut auth_dot_json = AuthDotJson {\n            openai_api_key: None,\n            tokens: None,\n            last_refresh: None,\n            accounts: vec![account],\n            current_account_index: Some(0),\n            rotation_enabled: Some(false),\n        };\n        auth_dot_json.normalize();\n\n        let auth_dot_json = Arc::new(Mutex::new(Some(auth_dot_json)));\n        Self {\n            api_key: None,\n            mode: AuthMode::ChatGPT,\n            active_account_index: Some(0),\n            auth_file: PathBuf::new(),\n            auth_dot_json,\n            client: crate::default_client::create_client(),\n        }\n    }\n\n    fn from_api_key_with_client(api_key: &str, client: reqwest::Client) -> Self {\n        Self {\n            api_key: Some(api_key.to_owned()),\n            mode: AuthMode::ApiKey,\n            active_account_index: None,\n            auth_file: PathBuf::new(),\n            auth_dot_json: Arc::new(Mutex::new(None)),\n            client,\n        }\n    }\n\n    pub fn from_api_key(api_key: &str) -> Self {\n        Self::from_api_key_with_client(api_key, crate::default_client::create_client())\n    }\n}\n\npub const OPENAI_API_KEY_ENV_VAR: &str = \"OPENAI_API_KEY\";\n\npub fn read_openai_api_key_from_env() -> Option<String> {\n    env::var(OPENAI_API_KEY_ENV_VAR)\n        .ok()\n        .map(|value| value.trim().to_string())\n        .filter(|value| !value.is_empty())\n}\n\nfn auth_pool_path(codex_home: &Path) -> PathBuf {\n    codex_home.join(\"auth_pool.json\")\n}\n\nfn legacy_auth_path(codex_home: &Path) -> PathBuf {\n    codex_home.join(\"auth.json\")\n}\n\n/// Returns the canonical path Codex uses to persist authentication state.\n/// The new default is `$CODEX_HOME/auth_pool.json` (multi-account aware).\npub fn get_auth_file(codex_home: &Path) -> PathBuf {\n    auth_pool_path(codex_home)\n}\n\n/// Returns the best available authentication file for reading:\n/// prefers `auth_pool.json` and falls back to legacy `auth.json` if needed.\npub fn find_auth_file(codex_home: &Path) -> Option<PathBuf> {\n    let pool = auth_pool_path(codex_home);\n    if pool.exists() {\n        Some(pool)\n    } else {\n        let legacy = legacy_auth_path(codex_home);\n        if legacy.exists() { Some(legacy) } else { None }\n    }\n}\n\n/// Delete the auth.json file inside `codex_home` if it exists. Returns `Ok(true)`\n/// if a file was removed, `Ok(false)` if no auth file was present.\npub fn logout(codex_home: &Path) -> std::io::Result<bool> {\n    let mut removed = false;\n    for path in [auth_pool_path(codex_home), legacy_auth_path(codex_home)] {\n        match std::fs::remove_file(&path) {\n            Ok(_) => removed = true,\n            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {}\n            Err(err) => return Err(err),\n        }\n    }\n    Ok(removed)\n}\n\n/// Writes an `auth.json` that contains only the API key.\npub fn login_with_api_key(codex_home: &Path, api_key: &str) -> std::io::Result<()> {\n    let auth_dot_json = AuthDotJson {\n        openai_api_key: Some(api_key.to_string()),\n        tokens: None,\n        last_refresh: None,\n        accounts: Vec::new(),\n        current_account_index: None,\n        rotation_enabled: None,\n    };\n    write_auth_json(&get_auth_file(codex_home), &auth_dot_json)\n}\n\nfn load_auth(codex_home: &Path) -> std::io::Result<Option<CodexAuth>> {\n    let client = crate::default_client::create_client();\n    let canonical_file = get_auth_file(codex_home);\n\n    let source_file = match find_auth_file(codex_home) {\n        Some(path) => path,\n        None => return Ok(None),\n    };\n\n    let mut auth_dot_json = match try_read_auth_json(&source_file) {\n        Ok(auth) => auth,\n        Err(e) => {\n            return Err(e);\n        }\n    };\n\n    if source_file != canonical_file {\n        // Migrate legacy auth.json into the canonical auth_pool.json.\n        write_auth_json(&canonical_file, &auth_dot_json)?;\n        auth_dot_json = try_read_auth_json(&canonical_file)?;\n    }\n\n    if let Some(account) = auth_dot_json.active_account() {\n        if let Some(api_key) = &account.openai_api_key {\n            return Ok(Some(CodexAuth::from_api_key_with_client(api_key, client)));\n        }\n    }\n\n    if let Some(api_key) = &auth_dot_json.openai_api_key {\n        return Ok(Some(CodexAuth::from_api_key_with_client(api_key, client)));\n    }\n\n    if auth_dot_json\n        .active_account()\n        .and_then(|account| account.tokens.as_ref())\n        .is_none()\n    {\n        return Ok(None);\n    }\n\n    auth_dot_json.normalize();\n    refresh_account_pool_snapshot(&auth_dot_json);\n    let active_account_index = auth_dot_json.current_account_index;\n\n    Ok(Some(CodexAuth {\n        api_key: None,\n        mode: AuthMode::ChatGPT,\n        auth_file: canonical_file,\n        active_account_index,\n        auth_dot_json: Arc::new(Mutex::new(Some(auth_dot_json))),\n        client,\n    }))\n}\n\n/// Attempt to read and refresh the `auth.json` file in the given `CODEX_HOME` directory.\n/// Returns the full AuthDotJson structure after refreshing if necessary.\npub fn try_read_auth_json(auth_file: &Path) -> std::io::Result<AuthDotJson> {\n    let mut file = File::open(auth_file)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    let mut auth_dot_json: AuthDotJson = serde_json::from_str(&contents)?;\n    auth_dot_json.normalize();\n\n    Ok(auth_dot_json)\n}\n\npub fn write_auth_json(auth_file: &Path, auth_dot_json: &AuthDotJson) -> std::io::Result<()> {\n    let mut normalized = auth_dot_json.clone();\n    normalized.normalize();\n    refresh_account_pool_snapshot(&normalized);\n    let json_data = serde_json::to_string_pretty(&normalized)?;\n    let mut options = OpenOptions::new();\n    options.truncate(true).write(true).create(true);\n    #[cfg(unix)]\n    {\n        options.mode(0o600);\n    }\n    let mut file = options.open(auth_file)?;\n    file.write_all(json_data.as_bytes())?;\n    file.flush()?;\n    Ok(())\n}\n\nasync fn update_tokens(\n    auth_file: &Path,\n    account_index: Option<usize>,\n    id_token: String,\n    access_token: Option<String>,\n    refresh_token: Option<String>,\n) -> std::io::Result<AuthDotJson> {\n    let mut auth_dot_json = try_read_auth_json(auth_file)?;\n\n    let idx = account_index.unwrap_or_else(|| auth_dot_json.active_index());\n    let account = auth_dot_json\n        .accounts\n        .get_mut(idx)\n        .ok_or_else(|| std::io::Error::other(\"Account index out of bounds\"))?;\n\n    let tokens = account.tokens.get_or_insert_with(TokenData::default);\n    tokens.id_token = parse_id_token(&id_token).map_err(std::io::Error::other)?;\n    if let Some(access_token) = access_token {\n        tokens.access_token = access_token;\n    }\n    if let Some(refresh_token) = refresh_token {\n        tokens.refresh_token = refresh_token;\n    }\n    account.last_refresh = Some(Utc::now());\n    account.clear_rate_limit();\n    auth_dot_json.set_active_index(idx);\n\n    write_auth_json(auth_file, &auth_dot_json)?;\n    let mut updated = auth_dot_json.clone();\n    updated.normalize();\n    Ok(updated)\n}\n\nasync fn try_refresh_token(\n    refresh_token: String,\n    client: &reqwest::Client,\n) -> std::io::Result<RefreshResponse> {\n    let refresh_request = RefreshRequest {\n        client_id: CLIENT_ID,\n        grant_type: \"refresh_token\",\n        refresh_token,\n        scope: \"openid profile email\",\n    };\n\n    // Use shared client factory to include standard headers\n    let response = client\n        .post(\"https://auth.openai.com/oauth/token\")\n        .header(\"Content-Type\", \"application/json\")\n        .json(&refresh_request)\n        .send()\n        .await\n        .map_err(std::io::Error::other)?;\n\n    if response.status().is_success() {\n        let refresh_response = response\n            .json::<RefreshResponse>()\n            .await\n            .map_err(std::io::Error::other)?;\n        Ok(refresh_response)\n    } else {\n        Err(std::io::Error::other(format!(\n            \"Failed to refresh token: {}\",\n            response.status()\n        )))\n    }\n}\n\n#[derive(Serialize)]\nstruct RefreshRequest {\n    client_id: &'static str,\n    grant_type: &'static str,\n    refresh_token: String,\n    scope: &'static str,\n}\n\n#[derive(Deserialize, Clone)]\nstruct RefreshResponse {\n    id_token: String,\n    access_token: Option<String>,\n    refresh_token: Option<String>,\n}\n\n/// Represents the serialized auth.json document. Legacy (single-account) files\n/// populate only the top-level fields. When account rotation is enabled the\n/// `accounts` list stores individual entries together with rotation metadata.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct AuthDotJson {\n    #[serde(\n        rename = \"OPENAI_API_KEY\",\n        default,\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub openai_api_key: Option<String>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tokens: Option<TokenData>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub last_refresh: Option<DateTime<Utc>>,\n\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub accounts: Vec<AuthAccount>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub current_account_index: Option<usize>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub rotation_enabled: Option<bool>,\n}\n\n/// Single account entry inside the auth pool. The legacy single-account format\n/// is mapped to a vector that contains exactly one element of this struct.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct AuthAccount {\n    #[serde(\n        rename = \"OPENAI_API_KEY\",\n        default,\n        skip_serializing_if = \"Option::is_none\"\n    )]\n    pub openai_api_key: Option<String>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub tokens: Option<TokenData>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub last_refresh: Option<DateTime<Utc>>,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub rate_limit_reset: Option<DateTime<Utc>>,\n}\n\nimpl AuthDotJson {\n    fn normalize(&mut self) {\n        if self.accounts.is_empty() {\n            self.accounts.push(AuthAccount {\n                openai_api_key: self.openai_api_key.clone(),\n                tokens: self.tokens.clone(),\n                last_refresh: self.last_refresh,\n                rate_limit_reset: None,\n            });\n        }\n\n        if self.current_account_index.is_none() {\n            self.current_account_index = Some(0);\n        }\n\n        let len = self.accounts.len();\n        if len == 0 {\n            self.current_account_index = Some(0);\n        } else if let Some(idx) = self.current_account_index {\n            if idx >= len {\n                self.current_account_index = Some(0);\n            }\n        }\n\n        if self.rotation_enabled.is_none() {\n            let enabled = self.accounts.len() > 1;\n            self.rotation_enabled = Some(enabled);\n        }\n\n        let idx = self.active_index();\n        if let Some(account) = self.accounts.get(idx) {\n            self.openai_api_key = account.openai_api_key.clone();\n            self.tokens = account.tokens.clone();\n            self.last_refresh = account.last_refresh;\n        }\n    }\n\n    pub fn active_index(&self) -> usize {\n        let len = self.accounts.len();\n        if len == 0 {\n            return 0;\n        }\n        self.current_account_index.unwrap_or(0).min(len - 1)\n    }\n\n    fn active_account(&self) -> Option<&AuthAccount> {\n        if self.accounts.is_empty() {\n            return None;\n        }\n        let idx = self.active_index();\n        self.accounts.get(idx)\n    }\n\n    pub fn rotation_enabled(&self) -> bool {\n        self.rotation_enabled.unwrap_or(false)\n    }\n\n    fn set_active_index(&mut self, idx: usize) {\n        if self.accounts.is_empty() {\n            self.accounts.push(AuthAccount {\n                openai_api_key: self.openai_api_key.clone(),\n                tokens: self.tokens.clone(),\n                last_refresh: self.last_refresh,\n                rate_limit_reset: None,\n            });\n        }\n        let len = self.accounts.len();\n        let bounded = if len == 0 { 0 } else { idx.min(len - 1) };\n        self.current_account_index = Some(bounded);\n        if let Some(account) = self.accounts.get(bounded) {\n            self.openai_api_key = account.openai_api_key.clone();\n            self.tokens = account.tokens.clone();\n            self.last_refresh = account.last_refresh;\n        }\n    }\n\n    fn mark_rate_limited(&mut self, idx: usize, reset_at: Option<DateTime<Utc>>) {\n        if let Some(account) = self.accounts.get_mut(idx) {\n            account.rate_limit_reset = reset_at;\n        }\n    }\n}\n\nimpl AuthAccount {\n    fn is_available(&self, now: DateTime<Utc>) -> bool {\n        match self.rate_limit_reset {\n            Some(reset) => reset <= now,\n            None => true,\n        }\n    }\n\n    fn clear_rate_limit(&mut self) {\n        self.rate_limit_reset = None;\n    }\n}\n\n// Shared constant for token refresh (client id used for oauth token refresh flow)\npub const CLIENT_ID: &str = \"app_EMoamEEZ73f0CkXaXp7hrann\";\n\nuse std::sync::RwLock;\n\n/// Internal cached auth state.\n#[derive(Clone, Debug)]\nstruct CachedAuth {\n    auth: Option<CodexAuth>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::token_data::IdTokenInfo;\n    use crate::token_data::KnownPlan;\n    use crate::token_data::PlanType;\n    use base64::Engine;\n    use pretty_assertions::assert_eq;\n    use serde::Serialize;\n    use serde_json::json;\n    use tempfile::tempdir;\n\n    const LAST_REFRESH: &str = \"2025-08-06T20:41:36.232376Z\";\n    const SAMPLE_JWT: &str = \"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.e30.c2ln\";\n\n    #[tokio::test]\n    async fn roundtrip_auth_dot_json() {\n        let codex_home = tempdir().unwrap();\n        let _ = write_auth_file(\n            AuthFileParams {\n                openai_api_key: None,\n                chatgpt_plan_type: \"pro\".to_string(),\n            },\n            codex_home.path(),\n        )\n        .expect(\"failed to write auth file\");\n\n        let file = get_auth_file(codex_home.path());\n        let auth_dot_json = try_read_auth_json(&file).unwrap();\n        write_auth_json(&file, &auth_dot_json).unwrap();\n\n        let same_auth_dot_json = try_read_auth_json(&file).unwrap();\n        assert_eq!(auth_dot_json, same_auth_dot_json);\n    }\n\n    #[test]\n    fn login_with_api_key_overwrites_existing_auth_json() {\n        let dir = tempdir().unwrap();\n        let auth_path = dir.path().join(\"auth.json\");\n        let stale_auth = json!({\n            \"OPENAI_API_KEY\": \"sk-old\",\n            \"tokens\": {\n                \"id_token\": \"stale.header.payload\",\n                \"access_token\": \"stale-access\",\n                \"refresh_token\": \"stale-refresh\",\n                \"account_id\": \"stale-acc\"\n            }\n        });\n        std::fs::write(\n            &auth_path,\n            serde_json::to_string_pretty(&stale_auth).unwrap(),\n        )\n        .unwrap();\n\n        super::login_with_api_key(dir.path(), \"sk-new\").expect(\"login_with_api_key should succeed\");\n\n        let canonical = get_auth_file(dir.path());\n        assert!(canonical.exists(), \"canonical auth file should be created\");\n        let auth = super::try_read_auth_json(&canonical).expect(\"auth file should parse\");\n        assert_eq!(auth.openai_api_key.as_deref(), Some(\"sk-new\"));\n        assert!(auth.tokens.is_none(), \"tokens should be cleared\");\n    }\n\n    #[tokio::test]\n    async fn pro_account_with_no_api_key_uses_chatgpt_auth() {\n        let codex_home = tempdir().unwrap();\n        let fake_jwt = write_auth_file(\n            AuthFileParams {\n                openai_api_key: None,\n                chatgpt_plan_type: \"pro\".to_string(),\n            },\n            codex_home.path(),\n        )\n        .expect(\"failed to write auth file\");\n\n        let CodexAuth {\n            api_key,\n            mode,\n            auth_dot_json,\n            auth_file: _,\n            ..\n        } = super::load_auth(codex_home.path()).unwrap().unwrap();\n        assert_eq!(None, api_key);\n        assert_eq!(AuthMode::ChatGPT, mode);\n\n        let guard = auth_dot_json.lock().unwrap();\n        let auth_dot_json = guard.as_ref().expect(\"AuthDotJson should exist\");\n        assert_eq!(\n            &AuthDotJson {\n                openai_api_key: None,\n                tokens: Some(TokenData {\n                    id_token: IdTokenInfo {\n                        email: Some(\"user@example.com\".to_string()),\n                        chatgpt_plan_type: Some(PlanType::Known(KnownPlan::Pro)),\n                        raw_jwt: fake_jwt.clone(),\n                    },\n                    access_token: \"test-access-token\".to_string(),\n                    refresh_token: \"test-refresh-token\".to_string(),\n                    account_id: None,\n                }),\n                last_refresh: Some(\n                    DateTime::parse_from_rfc3339(LAST_REFRESH)\n                        .unwrap()\n                        .with_timezone(&Utc)\n                ),\n                accounts: vec![AuthAccount {\n                    openai_api_key: None,\n                    tokens: Some(TokenData {\n                        id_token: IdTokenInfo {\n                            email: Some(\"user@example.com\".to_string()),\n                            chatgpt_plan_type: Some(PlanType::Known(KnownPlan::Pro)),\n                            raw_jwt: fake_jwt,\n                        },\n                        access_token: \"test-access-token\".to_string(),\n                        refresh_token: \"test-refresh-token\".to_string(),\n                        account_id: None,\n                    }),\n                    last_refresh: Some(\n                        DateTime::parse_from_rfc3339(LAST_REFRESH)\n                            .unwrap()\n                            .with_timezone(&Utc)\n                    ),\n                    rate_limit_reset: None,\n                }],\n                current_account_index: Some(0),\n                rotation_enabled: Some(false),\n            },\n            auth_dot_json\n        )\n    }\n\n    #[tokio::test]\n    async fn loads_api_key_from_auth_json() {\n        let dir = tempdir().unwrap();\n        let auth_file = dir.path().join(\"auth.json\");\n        std::fs::write(\n            auth_file,\n            r#\"{\"OPENAI_API_KEY\":\"sk-test-key\",\"tokens\":null,\"last_refresh\":null}\"#,\n        )\n        .unwrap();\n\n        let auth = super::load_auth(dir.path()).unwrap().unwrap();\n        assert_eq!(auth.mode, AuthMode::ApiKey);\n        assert_eq!(auth.api_key, Some(\"sk-test-key\".to_string()));\n\n        assert!(auth.get_token_data().await.is_err());\n    }\n\n    #[test]\n    fn logout_removes_auth_file() -> Result<(), std::io::Error> {\n        let dir = tempdir()?;\n        let auth_dot_json = AuthDotJson {\n            openai_api_key: Some(\"sk-test-key\".to_string()),\n            tokens: None,\n            last_refresh: None,\n            accounts: Vec::new(),\n            current_account_index: None,\n            rotation_enabled: None,\n        };\n        let canonical = get_auth_file(dir.path());\n        write_auth_json(&canonical, &auth_dot_json)?;\n        assert!(canonical.exists());\n        // Simulate legacy file lingering on disk.\n        let legacy = legacy_auth_path(dir.path());\n        std::fs::write(&legacy, \"legacy\").unwrap();\n        let removed = logout(dir.path())?;\n        assert!(removed);\n        assert!(!canonical.exists());\n        assert!(!legacy.exists());\n        Ok(())\n    }\n\n    #[test]\n    fn rotates_to_next_available_account() {\n        let dir = tempdir().unwrap();\n        let auth_file = get_auth_file(dir.path());\n\n        let account0 = AuthAccount {\n            openai_api_key: None,\n            tokens: Some(TokenData {\n                id_token: IdTokenInfo {\n                    email: None,\n                    chatgpt_plan_type: None,\n                    raw_jwt: SAMPLE_JWT.to_string(),\n                },\n                access_token: \"access0\".to_string(),\n                refresh_token: \"refresh0\".to_string(),\n                account_id: Some(\"account0\".to_string()),\n            }),\n            last_refresh: Some(Utc::now()),\n            rate_limit_reset: None,\n        };\n\n        let account1 = AuthAccount {\n            openai_api_key: None,\n            tokens: Some(TokenData {\n                id_token: IdTokenInfo {\n                    email: None,\n                    chatgpt_plan_type: None,\n                    raw_jwt: SAMPLE_JWT.to_string(),\n                },\n                access_token: \"access1\".to_string(),\n                refresh_token: \"refresh1\".to_string(),\n                account_id: Some(\"account1\".to_string()),\n            }),\n            last_refresh: Some(Utc::now()),\n            rate_limit_reset: None,\n        };\n\n        let auth = AuthDotJson {\n            openai_api_key: None,\n            tokens: None,\n            last_refresh: None,\n            accounts: vec![account0, account1],\n            current_account_index: Some(0),\n            rotation_enabled: Some(true),\n        };\n        write_auth_json(&auth_file, &auth).unwrap();\n\n        let manager = AuthManager::shared(dir.path().to_path_buf());\n        let initial = manager.auth().unwrap();\n        assert_eq!(initial.active_account_index, Some(0));\n\n        manager.mark_current_rate_limited(Some(120)).unwrap();\n        assert!(manager.switch_to_next_account().unwrap());\n\n        let rotated = manager.auth().unwrap();\n        assert_eq!(rotated.active_account_index, Some(1));\n\n        let persisted = try_read_auth_json(&auth_file).unwrap();\n        assert_eq!(persisted.current_account_index, Some(1));\n        assert!(persisted.accounts[0].rate_limit_reset.is_some());\n        assert!(persisted.accounts[1].rate_limit_reset.is_none());\n        assert_eq!(\n            persisted.accounts[1].tokens.as_ref().unwrap().access_token,\n            \"access1\"\n        );\n    }\n\n    #[test]\n    fn rotation_respects_disabled_flag() {\n        let dir = tempdir().unwrap();\n        let auth_file = get_auth_file(dir.path());\n\n        let account = AuthAccount {\n            openai_api_key: None,\n            tokens: Some(TokenData {\n                id_token: IdTokenInfo {\n                    email: None,\n                    chatgpt_plan_type: None,\n                    raw_jwt: SAMPLE_JWT.to_string(),\n                },\n                access_token: \"access\".to_string(),\n                refresh_token: \"refresh\".to_string(),\n                account_id: Some(\"account\".to_string()),\n            }),\n            last_refresh: Some(Utc::now()),\n            rate_limit_reset: None,\n        };\n\n        let account_b = AuthAccount {\n            openai_api_key: None,\n            tokens: Some(TokenData {\n                id_token: IdTokenInfo {\n                    email: None,\n                    chatgpt_plan_type: None,\n                    raw_jwt: SAMPLE_JWT.to_string(),\n                },\n                access_token: \"access-b\".to_string(),\n                refresh_token: \"refresh-b\".to_string(),\n                account_id: Some(\"account-b\".to_string()),\n            }),\n            last_refresh: Some(Utc::now()),\n            rate_limit_reset: None,\n        };\n\n        let auth = AuthDotJson {\n            openai_api_key: None,\n            tokens: None,\n            last_refresh: None,\n            accounts: vec![account, account_b],\n            current_account_index: Some(0),\n            rotation_enabled: Some(false),\n        };\n        write_auth_json(&auth_file, &auth).unwrap();\n\n        let manager = AuthManager::shared(dir.path().to_path_buf());\n        manager.mark_current_rate_limited(Some(30)).unwrap();\n        assert!(!manager.switch_to_next_account().unwrap());\n    }\n\n    struct AuthFileParams {\n        openai_api_key: Option<String>,\n        chatgpt_plan_type: String,\n    }\n\n    fn write_auth_file(params: AuthFileParams, codex_home: &Path) -> std::io::Result<String> {\n        let auth_file = get_auth_file(codex_home);\n        // Create a minimal valid JWT for the id_token field.\n        #[derive(Serialize)]\n        struct Header {\n            alg: &'static str,\n            typ: &'static str,\n        }\n        let header = Header {\n            alg: \"none\",\n            typ: \"JWT\",\n        };\n        let payload = serde_json::json!({\n            \"email\": \"user@example.com\",\n            \"email_verified\": true,\n            \"https://api.openai.com/auth\": {\n                \"chatgpt_account_id\": \"bc3618e3-489d-4d49-9362-1561dc53ba53\",\n                \"chatgpt_plan_type\": params.chatgpt_plan_type,\n                \"chatgpt_user_id\": \"user-12345\",\n                \"user_id\": \"user-12345\",\n            }\n        });\n        let b64 = |b: &[u8]| base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(b);\n        let header_b64 = b64(&serde_json::to_vec(&header)?);\n        let payload_b64 = b64(&serde_json::to_vec(&payload)?);\n        let signature_b64 = b64(b\"sig\");\n        let fake_jwt = format!(\"{header_b64}.{payload_b64}.{signature_b64}\");\n\n        let auth_json_data = json!({\n            \"OPENAI_API_KEY\": params.openai_api_key,\n            \"tokens\": {\n                \"id_token\": fake_jwt,\n                \"access_token\": \"test-access-token\",\n                \"refresh_token\": \"test-refresh-token\"\n            },\n            \"last_refresh\": LAST_REFRESH,\n        });\n        let auth_json = serde_json::to_string_pretty(&auth_json_data)?;\n        std::fs::write(auth_file, auth_json)?;\n        Ok(fake_jwt)\n    }\n}\n\n/// Central manager providing a single source of truth for auth.json derived\n/// authentication data. It loads once (or on preference change) and then\n/// hands out cloned `CodexAuth` values so the rest of the program has a\n/// consistent snapshot.\n///\n/// External modifications to `auth.json` will NOT be observed until\n/// `reload()` is called explicitly. This matches the design goal of avoiding\n/// different parts of the program seeing inconsistent auth data mid‑run.\n#[derive(Debug)]\npub struct AuthManager {\n    codex_home: PathBuf,\n    inner: RwLock<CachedAuth>,\n}\n\nimpl AuthManager {\n    /// Create a new manager loading the initial auth using the provided\n    /// preferred auth method. Errors loading auth are swallowed; `auth()` will\n    /// simply return `None` in that case so callers can treat it as an\n    /// unauthenticated state.\n    pub fn new(codex_home: PathBuf) -> Self {\n        let auth = CodexAuth::from_codex_home(&codex_home).ok().flatten();\n        Self {\n            codex_home,\n            inner: RwLock::new(CachedAuth { auth }),\n        }\n    }\n\n    /// Create an AuthManager with a specific CodexAuth, for testing only.\n    pub fn from_auth_for_testing(auth: CodexAuth) -> Arc<Self> {\n        let cached = CachedAuth { auth: Some(auth) };\n        Arc::new(Self {\n            codex_home: PathBuf::new(),\n            inner: RwLock::new(cached),\n        })\n    }\n\n    /// Current cached auth (clone). May be `None` if not logged in or load failed.\n    pub fn auth(&self) -> Option<CodexAuth> {\n        self.inner.read().ok().and_then(|c| c.auth.clone())\n    }\n\n    /// Force a reload of the auth information from auth.json. Returns\n    /// whether the auth value changed.\n    pub fn reload(&self) -> bool {\n        let new_auth = CodexAuth::from_codex_home(&self.codex_home).ok().flatten();\n        if let Ok(mut guard) = self.inner.write() {\n            let changed = !AuthManager::auths_equal(&guard.auth, &new_auth);\n            guard.auth = new_auth;\n            changed\n        } else {\n            false\n        }\n    }\n\n    fn auths_equal(a: &Option<CodexAuth>, b: &Option<CodexAuth>) -> bool {\n        match (a, b) {\n            (None, None) => true,\n            (Some(a), Some(b)) => a == b,\n            _ => false,\n        }\n    }\n\n    /// Convenience constructor returning an `Arc` wrapper.\n    pub fn shared(codex_home: PathBuf) -> Arc<Self> {\n        Arc::new(Self::new(codex_home))\n    }\n\n    /// Attempt to refresh the current auth token (if any). On success, reload\n    /// the auth state from disk so other components observe refreshed token.\n    pub async fn refresh_token(&self) -> std::io::Result<Option<String>> {\n        let auth = match self.auth() {\n            Some(a) => a,\n            None => return Ok(None),\n        };\n        match auth.refresh_token().await {\n            Ok(token) => {\n                // Reload to pick up persisted changes.\n                self.reload();\n                Ok(Some(token))\n            }\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Log out by deleting the on‑disk auth.json (if present). Returns Ok(true)\n    /// if a file was removed, Ok(false) if no auth file existed. On success,\n    /// reloads the in‑memory auth cache so callers immediately observe the\n    /// unauthenticated state.\n    pub fn logout(&self) -> std::io::Result<bool> {\n        let removed = super::auth::logout(&self.codex_home)?;\n        // Always reload to clear any cached auth (even if file absent).\n        self.reload();\n        Ok(removed)\n    }\n\n    pub fn mark_current_rate_limited(&self, resets_in_seconds: Option<u64>) -> std::io::Result<()> {\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n        if auth_dot_json.accounts.is_empty() {\n            return Ok(());\n        }\n\n        let secs = resets_in_seconds.unwrap_or(60);\n        let capped_secs = std::cmp::min(secs, i64::MAX as u64) as i64;\n        let reset_at = Utc::now() + chrono::Duration::seconds(capped_secs);\n\n        let idx = auth_dot_json.active_index();\n        auth_dot_json.mark_rate_limited(idx, Some(reset_at));\n        write_auth_json(&auth_file, &auth_dot_json)?;\n        self.reload();\n        update_account_pool_state(|state| {\n            state.last_rate_limit_at = Some(Utc::now());\n        });\n        Ok(())\n    }\n\n    pub fn switch_to_next_account(&self) -> std::io::Result<bool> {\n        let auth_file = get_auth_file(&self.codex_home);\n        let mut auth_dot_json = try_read_auth_json(&auth_file)?;\n\n        if !auth_dot_json.rotation_enabled() {\n            return Ok(false);\n        }\n\n        let total = auth_dot_json.accounts.len();\n        if total <= 1 {\n            return Ok(false);\n        }\n\n        let current = auth_dot_json.active_index();\n        let now = Utc::now();\n\n        for offset in 1..total {\n            let candidate = (current + offset) % total;\n            let available = auth_dot_json\n                .accounts\n                .get(candidate)\n                .map(|account| account.is_available(now) && account.tokens.is_some())\n                .unwrap_or(false);\n\n            if available {\n                auth_dot_json.set_active_index(candidate);\n                if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {\n                    account.clear_rate_limit();\n                }\n                write_auth_json(&auth_file, &auth_dot_json)?;\n                self.reload();\n                update_account_pool_state(|state| {\n                    state.last_rotation_at = Some(Utc::now());\n                });\n                return Ok(true);\n            }\n        }\n\n        Ok(false)\n    }\n}\n#[derive(Debug, Clone)]\npub struct AccountPoolState {\n    pub total_accounts: usize,\n    pub active_index: Option<usize>,\n    pub rotation_enabled: bool,\n    pub available_accounts: usize,\n    pub cooldown_accounts: usize,\n    pub inactive_accounts: usize,\n    pub next_available_at: Option<DateTime<Utc>>,\n    pub rate_limited_accounts: usize,\n    pub last_rate_limit_at: Option<DateTime<Utc>>,\n    pub last_rotation_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct AccountPoolSummary {\n    pub total_accounts: usize,\n    pub active_index: Option<usize>,\n    pub rotation_enabled: bool,\n    pub available_accounts: usize,\n    pub cooldown_accounts: usize,\n    pub inactive_accounts: usize,\n    pub next_available_at: Option<DateTime<Utc>>,\n    pub rate_limited_accounts: usize,\n    pub last_rate_limit_at: Option<DateTime<Utc>>,\n    pub last_rotation_at: Option<DateTime<Utc>>,\n}\n\nimpl Default for AccountPoolState {\n    fn default() -> Self {\n        Self {\n            total_accounts: 0,\n            active_index: None,\n            rotation_enabled: false,\n            available_accounts: 0,\n            cooldown_accounts: 0,\n            inactive_accounts: 0,\n            next_available_at: None,\n            rate_limited_accounts: 0,\n            last_rate_limit_at: None,\n            last_rotation_at: None,\n        }\n    }\n}\n\nstatic ACCOUNT_POOL_STATE: Lazy<RwLock<AccountPoolState>> =\n    Lazy::new(|| RwLock::new(AccountPoolState::default()));\n\npub fn account_pool_state() -> AccountPoolState {\n    ACCOUNT_POOL_STATE\n        .read()\n        .map(|state| state.clone())\n        .unwrap_or_default()\n}\n\nfn update_account_pool_state<F>(update: F)\nwhere\n    F: FnOnce(&mut AccountPoolState),\n{\n    if let Ok(mut guard) = ACCOUNT_POOL_STATE.write() {\n        update(&mut guard);\n    }\n}\n\npub fn set_account_pool_state_for_testing(state: AccountPoolState) {\n    if let Ok(mut guard) = ACCOUNT_POOL_STATE.write() {\n        *guard = state;\n    }\n}\n\nfn refresh_account_pool_snapshot(auth: &AuthDotJson) {\n    let total_accounts = auth.accounts.len();\n    let active_index = if total_accounts == 0 {\n        None\n    } else {\n        Some(auth.active_index())\n    };\n    let rotation_enabled = auth.rotation_enabled();\n    let now = Utc::now();\n    let mut available_accounts = 0usize;\n    let mut cooldown_accounts = 0usize;\n    let mut inactive_accounts = 0usize;\n    let mut next_available_at: Option<DateTime<Utc>> = None;\n\n    for account in &auth.accounts {\n        let has_tokens = account\n            .tokens\n            .as_ref()\n            .map(|tokens| !tokens.access_token.is_empty() && !tokens.refresh_token.is_empty())\n            .unwrap_or(false);\n\n        if !has_tokens {\n            inactive_accounts += 1;\n            continue;\n        }\n\n        if let Some(reset_at) = account.rate_limit_reset {\n            if reset_at > now {\n                cooldown_accounts += 1;\n                next_available_at = match next_available_at {\n                    Some(current) if current <= reset_at => Some(current),\n                    _ => Some(reset_at),\n                };\n                continue;\n            }\n        }\n\n        available_accounts += 1;\n    }\n\n    let rate_limited_accounts = cooldown_accounts;\n\n    update_account_pool_state(|state| {\n        state.total_accounts = total_accounts;\n        state.active_index = active_index;\n        state.rotation_enabled = rotation_enabled;\n        state.available_accounts = available_accounts;\n        state.cooldown_accounts = cooldown_accounts;\n        state.inactive_accounts = inactive_accounts;\n        state.next_available_at = next_available_at;\n        state.rate_limited_accounts = rate_limited_accounts;\n    });\n}\n","structuredPatch":[{"oldStart":1080,"oldLines":43,"newStart":1080,"newLines":69,"lines":["     }"," ","     pub fn switch_to_next_account(&self) -> std::io::Result<bool> {","+        use tracing::debug;","+        use tracing::warn;","+","         let auth_file = get_auth_file(&self.codex_home);","         let mut auth_dot_json = try_read_auth_json(&auth_file)?;"," ","         if !auth_dot_json.rotation_enabled() {","+            debug!(\"Account rotation disabled\");","             return Ok(false);","         }"," ","         let total = auth_dot_json.accounts.len();","         if total <= 1 {","+            debug!(\"Only {} account(s) available, cannot rotate\", total);","             return Ok(false);","         }"," ","         let current = auth_dot_json.active_index();","         let now = Utc::now();","+        debug!(\"Current account index: {}, total accounts: {}\", current, total);"," ","         for offset in 1..total {","             let candidate = (current + offset) % total;","-            let available = auth_dot_json","-                .accounts","-                .get(candidate)","-                .map(|account| account.is_available(now) && account.tokens.is_some())","+            let account = match auth_dot_json.accounts.get(candidate) {","+                Some(acc) => acc,","+                None => {","+                    warn!(\"Account at index {} not found\", candidate);","+                    continue;","+                }","+            };","+","+            // Check if account has valid tokens","+            let has_valid_tokens = account.tokens.as_ref()","+                .map(|t| !t.access_token.is_empty() && !t.refresh_token.is_empty())","                 .unwrap_or(false);"," ","-            if available {","-                auth_dot_json.set_active_index(candidate);","-                if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {","-                    account.clear_rate_limit();","+            if !has_valid_tokens {","+                debug!(\"Account {} has no valid tokens, skipping\", candidate);","+                continue;","+            }","+","+            if !account.is_available(now) {","+                if let Some(reset) = account.rate_limit_reset {","+                    debug!(\"Account {} is rate limited until {}\", candidate, reset);","                 }","-                write_auth_json(&auth_file, &auth_dot_json)?;","-                self.reload();","-                update_account_pool_state(|state| {","-                    state.last_rotation_at = Some(Utc::now());","-                });","-                return Ok(true);","+                continue;","             }","+","+            debug!(\"Switching from account {} to account {}\", current, candidate);","+            auth_dot_json.set_active_index(candidate);","+            if let Some(account) = auth_dot_json.accounts.get_mut(candidate) {","+                account.clear_rate_limit();","+            }","+            write_auth_json(&auth_file, &auth_dot_json)?;","+            self.reload();","+            update_account_pool_state(|state| {","+                state.last_rotation_at = Some(Utc::now());","+            });","+            debug!(\"Successfully switched to account {}\", candidate);","+            return Ok(true);","         }"," ","+        warn!(\"No available accounts found for rotation. All {} accounts are either rate limited or have invalid tokens\", total);","         Ok(false)","     }"," }"]}],"userModified":false}}