# Управление пулом ChatGPT-аккаунтов (REQ-ACC-01, REQ-REL-01)

## Назначение
Документ фиксирует корпоративно-уровневую реализацию автоматического переключения между авторизованными ChatGPT-профилями в Codex. Цель — обеспечить непрерывность работы при достижении лимитов провайдера без вмешательства пользователя и без потери контекста активных сессий.

## Формат `$CODEX_HOME/auth.json`
- `accounts[]` — упорядоченный пул аккаунтов. Каждый элемент сериализуется структурой `AuthAccount`:
  - `OPENAI_API_KEY` *(опционально)* — API-ключ для аккаунтов, использующих прямой доступ.
  - `tokens` *(опционально)* — сериализованный `TokenData` (ChatGPT id/access/refresh токены, `account_id`).
  - `last_refresh` — `DateTime<Utc>` последнего обновления токенов.
  - `rate_limit_reset` — `DateTime<Utc>`, когда аккаунт снова доступен после лимита.
- `current_account_index` — индекс активного аккаунта (0-based). Обновляется при каждой ротации.
- `rotation_enabled` — флаг, разрешающий автоматическую ротацию. По умолчанию `true`, если в пуле более одного аккаунта.
- Поля верхнего уровня (`OPENAI_API_KEY`, `tokens`, `last_refresh`) остаются для обратной совместимости и всегда отражают текущий активный аккаунт.

### Пример
```json
{
  "accounts": [
    {
      "tokens": {
        "id_token": "<jwt-0>",
        "access_token": "access-0",
        "refresh_token": "refresh-0",
        "account_id": "acct-0"
      },
      "last_refresh": "2025-09-16T15:36:05.565548400Z",
      "rate_limit_reset": null
    },
    {
      "tokens": {
        "id_token": "<jwt-1>",
        "access_token": "access-1",
        "refresh_token": "refresh-1",
        "account_id": "acct-1"
      },
      "last_refresh": "2025-09-17T08:02:11.000000000Z",
      "rate_limit_reset": null
    }
  ],
  "current_account_index": 1,
  "rotation_enabled": true,
  "tokens": {
    "id_token": "<jwt-1>",
    "access_token": "access-1",
    "refresh_token": "refresh-1",
    "account_id": "acct-1"
  },
  "last_refresh": "2025-09-17T08:02:11.000000000Z"
}
```

## Жизненный цикл
1. **Загрузка:** `AuthManager` нормализует `auth.json`, заполняя отсутствующие поля и синхронизируя верхний уровень с активным аккаунтом.
2. **Рабочий запрос:** `client.rs` перед каждым HTTP-вызовом читает свежий `CodexAuth` через `AuthManager::auth()`.
3. **Достижение лимита:** при ответе `429 usage_limit_reached`:
   - `AuthManager::mark_current_rate_limited()` фиксирует `rate_limit_reset = now + Δt` (Δt из ответа либо 60s по умолчанию).
   - `AuthManager::switch_to_next_account()` выбирает следующий аккаунт с готовыми токенами и `rate_limit_reset ≤ now`.
   - При успешной ротации текущий запрос повторяется прозрачно для пользователя; попытка не учитывается в лимите повторов.
4. **Восстановление:** по истечении `rate_limit_reset` аккаунт автоматически становится доступным и может быть выбран повторно.

## Обратная совместимость
- Наследние файлы без `accounts[]` автоматически мигрируют в пул из одного элемента.
- CLI/TUI, использующие `AuthDotJson`, продолжают работать: верхние поля всегда указывают на активный профиль.
- Ротация отключена (`rotation_enabled = false`), если требуется фиксировать одиночный аккаунт.

## Наблюдаемость и безопасность
- Лог `debug!("Switched to next account due to rate limit")` фиксирует успешную ротацию; ошибки записываются через `warn!` без прерывания основного потока.
- `rate_limit_reset` хранится в UTC; значения > i64::MAX секунд насыщаются.
- Токены обновляются через `update_tokens(...)`, который очищает флаг лимита и синхронизирует JSON.

## Инструкции по эксплуатации
1. Авторизуйтесь в каждом аккаунте (через `codex login chatgpt`) — файл автоматически пополняется токенами.
2. Убедитесь, что все аккаунты присутствуют в `accounts[]` и `rotation_enabled = true`.
3. Для временной заморозки ротации установите `rotation_enabled = false` и перезапустите Codex.
4. При добавлении нового аккаунта обновите `auth.json` и выполните `codex status` для проверки активного профиля.

## Риски и меры смягчения
- **Обнаружение мульти-аккаунтов провайдером:** ротация выполняется только по таймауту лимита, без агрессивного чередования.
- **Потеря контекста:** переключение происходит между HTTP-повторами; состояние сессии сохраняется.
- **Повреждение файла:** все операции проходят через `write_auth_json`, обеспечивающий консистентность и права доступа `0600` на Unix.

## Связанные метрики
- `METRIC-REL-01`: отсутствие деградации доступности при лимитах.
- `METRIC-APDEX`: неизменный SLA при автоматическом повторе запроса.
- `audit_fallback_count`: остаётся нулевым при корректной ротации.

